=============================================================================================================

	Model-View-Controller (MVC) Konzept für diverse Applikationen 
	(GUI Toolkit neutral, bis auf FXView und FXViewModel)
	
	@Author 	hugo-lucca
	@Version	1.0 - 30.04.2016
=============================================================================================================

	Inhalte:
	=======
	- die Interfaces definieren die zwingend zu implementierenden Methoden (die Schnittstelle)
	- die abstrakten Klassen sind "Halbfabrikate", d.h. vorbereitete Implementationen für eine einfache Beerbung, so
	- dass nur noch der für die Applikation notwendige Code bei M, V und C implementiert werden muss 
	
	- Controller-Klassen (C):
		- ContollerInterface	Interface für alle Controller Klassen
		- Controller			Abstrakte Klasse für den Controller (C).
								Hat evtl. nur eine erbende Klasse, der MainController in der Applikation.
		
	- Model-Klassen (M):
		- ModelInterface	Interface für alle folgenden Model Klassen
		- DataModel			Abstrakte Klasse für ein komplettes Modell mit Datenstrukturen (D-M)
		- Model				Erweiterte Beispiel-Implementation vom DataModel und dient der Anwendung in ViewModel
		
	- View-Klassen (V):
		- ViewInterface		Interface für alle folgenden View Klassen
		- View				Abstrakte Klasse für ein View (V)
							Ein neutrales ViewModel lohn sich nicht, denn die Implementation ist trivial, s.u.

    - FX spezifische Views:
    	- FXSetting			Static Behälter für FX GUI Konstanten und Primary Stage		
		- FXView			Abstrakte Klasse für eine FX spezifische View
		- FXViewModel		Abstarkte Klasse für eine FXView mit lokalem Model
	
	Abhängigkeiten:
	==============
	- debug-Package
	- mvc.test-Package beinhaltet die Komponententests
	- die hiervon abgeleiteten C, M und V werden zu besseren Übersicht in separate packages gehalten 

	How to use:
	==========
	Die von der Applikation instanziierte Klasse MainController (extends Controller) instanziiert alle weiteren Komponenten, 
	wie Models und Views, alle mit eignen und eindeutigen Namen versehen, und verwaltet sie zentral und flexibel in Listen.
	Nur die erste View-Instanziierung führt am Ende des Konstruktors die Methode show() aus (wie setVisible(true) in Swing). 
	Damit wird dem Betriebssystem die Kontrolle über dieses Fenster übergeben. Der User bestimmt nun was laufen soll (Navigation)
	über die jeweilig instanziierten und mit Event-„Listener" versehene Buttons (siehe Einzel-Aktionen und Aktionsblöcke {...} 
	hinter den 'e->'. Einen Szenenwechsel erfolgt über die Methode this.getController().show("view-name").
	
	Für die Kommunikation mit dem Model kann man das gewünschte Model mit getController().getModel("model-name") aufrufen.
	Bei einem ActionModel wird nur die Methode doAction(...) implementiert, 
	und man kann so dort programmiert Aktionen vom View aus aufrufen.
	
	Die refreshView() Methode vom View wird dann automatisch aufgerufen, vorausgesetzt, 
	1. der Contructor meldet das View im Constructor beim entsprechenden Model an mit:
			getController().getModel("model-name").registerView(this)
	2. die Methode doAction(...) ruft intern die Methode refreshViews() nach getaner Arbeit auf.

	Bemerkung: Die Anmeldung beim eigenen lokalen Model im ViewModel erfolgt automatisch und auch das refreshView();
	Es ist zudem kein Problem, wenn das View gleichzeitig bei mehreren Model's angemeldet ist.
	
	Bei einem DataModel ist es zusätzlich Möglich einen direkten Datenaustausch zwischen Modell und View herzustellen. 
	Typischerweise wird in der View-Methode refreshView() den neuesten Datenstatus abgefragt und im eigenen View aktualisiert.
	Dafür ist es meist notwendig gewisse Daten-Anzeigeelemente als Attribut zu halten und zu verwalten.

==================================================================================================================================
 

 
 